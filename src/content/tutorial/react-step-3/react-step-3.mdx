---
title: Building with grid
internal: false
---

<AnchorLinks>

- [Introduction](#install-grid)
- [Installing new dependancies](#add-landing-page-grid)
- [Github Personal Access Token](#add-landing-page-content)
- [Data Fetching Component](#data-fetching-component)
- [Presentational Component](#presentational-component)

</AnchorLinks>

## Introduction

In this step, we'll be wiring up our application to connect with the [Github GraphQL API](https://developer.github.com/v4/). To do so, we'll be using Apollo Client, the front end component of the [Apollo Platform](https://www.apollographql.com/docs/intro/platform).

The Apollo platform provides several open source tools for using GraphQL throughout your application's stack. Apollo Client is a sophisticated GraphQL client that manages data and state in an application.

## Installing new dependancies

We need a few dependancies to incorporate Apollo into our application

```bash
yarn add apollo-boost graphql react-apollo
```

1. `apollo-boost` – Package containing everything you need to set up Apollo Client

1. `graphql` – parses your GraphQL queries

1. `react-apollo` – Apollo integration for React

## Github Personal Access Token

You'll need a personal access token from your github account in order to make requests to their API. Check out [this guide](https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line) to see how to get one.

When you get to the scope/permissions step, you can leave them all unchecked. We don't need any special permissions, we just need access to the public API.

Once you have your token, we need to put it in a place where create-react-app can use it. When your application is being built and developed, create-react-app will parse environmental variables in any file that ends with `.env` and make them available under `process.env.MY_VARIABLE`.

One caveat is that we need to start our variables with `REACT_APP_`. You can read more about environmental variables in [create-react-app's guide](https://facebook.github.io/create-react-app/docs/adding-custom-environment-variables).

Since we don't want to commit this file to git, we can put it in `.local.env` which is in our `.gitignore` list. Your file should just have a single line like this one, where the `x`s are replaced with your unique token.

```bash
REACT_APP_GITHUB_PERSONAL_ACCESS_TOKEN=xxxxxx
```

If you have your project running, you'll need to restart it to get access to this token.

## Connect to Apollo

The `react-apollo` library gives us an component that we need to put at the base of our application. Typically the best place for things that need to wrap the entire application is at the root of the application. For us, that's at `src/index.js`.

In our index.js, lets add the two imports we'll need Apollo to the GitHub API.

```javascript
import ApolloClient from 'apollo-boost';
import { ApolloProvider } from 'react-apollo';
```

Next, we'll make our client by providing a uri for the github graphql API as well as an authorization header using the environmental variable we just added to `.local.env`

```javascript
const client = new ApolloClient({
  uri: 'https://api.github.com/graphql',
  headers: {
    authorization: `Bearer ${
      process.env.REACT_APP_GITHUB_PERSONAL_ACCESS_TOKEN
    }`,
  },
});
```

We can make a new, `Root` component to pass into `ReactDOM.render` so that it's clear what's wrapping our application. At the same time, we'll pass in the client we just made as a prop to the `ApolloProvider` component.

```javascript
const Root = () => (
  <ApolloProvider client={client}>
    <Router>
      <App />
    </Router>
  </ApolloProvider>
);

ReactDOM.render(<Root />, document.getElementById('root'));
```

## Data Fetching Component

### Imports

At the top of the page, we'll need to import the components necessary for loading our data and rendering loading states.

```
import React, { useState } from 'react';
import { gql } from 'apollo-boost';
import { Query } from 'react-apollo';
import DataTable from './RepoTable';
import { Pagination, Link, DataTableSkeleton } from 'carbon-components-react';
```

### The Query

Next we'll assemble our graphql query to fetch only the data we need from the graphql API. We'll do this using the `gql` helper we just imported. The `gql` helper lets you write GraphQL queries using interpolated strings (backticks) in javascript. In addition, we'll be using the Query component from `react-apollo` which uses gives us some great information about our query's loading state in addition to the data.

If you'd like some more information regarding writing queries and using the Query component, I recommend [Apollo's documentation](https://www.apollographql.com/docs/tutorial/queries) on this topic.

```graphql
const REPO_QUERY = gql`
  query REPO_QUERY {
    # Let's use carbon as our organization
    organization(login: "carbon-design-system") {
      # We'll grab all the repositories in one go. To load more resources
      # continuously, see the advanced topics.
      repositories(first: 75, orderBy: { field: UPDATED_AT, direction: DESC }) {
        totalCount
        nodes {
          url
          homepageUrl
          issues(filterBy: { states: OPEN }) {
            totalCount
          }
          stargazers {
            totalCount
          }
          releases(first: 1) {
            totalCount
            nodes {
              name
            }
          }
          name
          updatedAt
          createdAt
          description
          id
        }
      }
    }
  }
`;
```

### Helpers

Below that, we'll define our table headers so they can be used both in the `DataTableSkeleton` and eventually the `DataTable` once we get our data. In addition, we'll define a `LinkList` component and a `getRowItems` helper that uses it to only pass down the rows

Because we can use the list of headers we want to display between the `DataTableSkeleton` and `DataTable` components, it makes sense for us to define it in one place with the parent component.

```js
const headers = [
  {
    key: 'name',
    header: 'Name',
  },
  {
    key: 'createdAt',
    header: 'Created',
  },
  {
    key: 'updatedAt',
    header: 'Updated',
  },
  {
    key: 'issueCount',
    header: 'Open Issues',
  },
  {
    key: 'stars',
    header: 'Stars',
  },
  {
    key: 'links',
    header: 'Links',
  },
];

const LinkList = ({ url, homepageUrl }) => (
  <ul style={{ display: 'flex' }}>
    <li>
      <Link href={url}>GitHub</Link>
    </li>
    {homepageUrl && (
      <li>
        <span>&nbsp;|&nbsp;</span>
        <Link href={homepageUrl}>Homepage</Link>
      </li>
    )}
  </ul>
);

const getRowItems = rows =>
  rows.map(row => ({
    ...row,
    key: row.id,
    stars: row.stargazers.totalCount,
    issueCount: row.issues.totalCount,
    createdAt: new Date(row.createdAt).toLocaleDateString(),
    updatedAt: new Date(row.updatedAt).toLocaleDateString(),
    links: <LinkList url={row.url} homepageUrl={row.homepageUrl} />,
  }));
```

### The `RepoPage` component

For the primary component, we'll be using [React Hooks](https://reactjs.org/docs/hooks-intro.html) too manage our state. Hooks are a relatively new React API that allows us to author a react component's stateful logic in a function component rather than a class component. Using hooks means we don't need to worry about complex lifecycle methods.

The Query component from `react-apollo` gives lets us render different content based on the state of our request. When `loading` is true, we'll render the `DataTableSkeleton` component from `carbon-components-react`. If there's an issue, we'll render the corresponding Error message.

Finally, if neither of those are true, it means we have our data! One nice advantage of GraphQL is that as long as there are no errors, we can be certain the properties on the data we requested isn't `undefined`.

```jsx
const RepoPage = () => {
  const [totalItems, setTotalItems] = useState(0);
  const [firstRowIndex, setFirstRowIndex] = useState(0);
  const [currentPageSize, setCurrentPageSize] = useState(10);

  return (
    <div className="repo-page">
      <Query query={REPO_QUERY}>
        {({ loading, error, data: { organization } }) => {
          // Waiting for the request to complete
          if (loading)
            return (
              <DataTableSkeleton
                columnCount={headers.length + 1}
                rowCount={12}
                headers={headers}
              />
            );

          // Something went wrong with the data fetching
          if (error) return `Error! ${error.message}`;

          // If we're here, we've got our data!
          const { repositories } = organization;
          setTotalItems(repositories.totalCount);

          // This is where we use our helper to turn our data into
          // the items we want rendered in our table cells.
          const rows = getRowItems(repositories.nodes);

          // Finally, let's return our Table and the corresponding Pagination component
          return (
            <>
              <DataTable
                headers={headers}
                rows={rows.slice(
                  firstRowIndex,
                  firstRowIndex + currentPageSize
                )}
              />
              <Pagination
                totalItems={totalItems}
                backwardText="Previous page"
                forwardText="Next page"
                pageSize={currentPageSize}
                pageSizes={[5, 10, 15, 25]}
                itemsPerPageText="Items per page"
                onChange={({ page, pageSize }) => {
                  if (pageSize !== currentPageSize) {
                    setCurrentPageSize(pageSize);
                  }
                  setFirstRowIndex(pageSize * (page - 1));
                }}
              />
            </>
          );
        }}
      </Query>
    </div>
  );
};

// Don't forget to export!
export default RepoPage;
```

### Render notes

- We only pass the rows that we want our table to display, we can do this by slicing the our array of rows depending on the first item and the page size.

- The Pagination component isn't inherently connected in any way to the
  DataTable, we need to tell it what to do when a change occurs using the onChange prop. This includes both page size changes and displaying different rows.

## Presentational component

Now we'll need to consume our fetched data. In React, we generally want to separate our data fetching logic from our presentational or visual content. We'll separate our visual content into the `RepoPage/RepoTable.js` file. It's important to keep in mind that because we only render our `RepoTable` when we have our data, we don't need to be as safe with null/undefined checking our individual row properties. We've established that they exist given the nature of our GraphQL query.

### Imports

Let's import all the various components we'll need to render our table

```javascript
import React from 'react';
import {
  DataTable,
  TableContainer,
  Table,
  TableHead,
  TableRow,
  TableExpandHeader,
  TableHeader,
  TableBody,
  TableExpandRow,
  TableCell,
  TableExpandedRow,
} from 'carbon-components-react';
```

### The `RepoTable` component

The DataTable component and it's pieces use a common react pattern called [render props](https://reactjs.org/docs/render-props.html). This a really powerful way for libraries to give developers control of rendering and manipulating their data.

We just need to pass in our row objects along with the headers for each column. In addition, we tell the DataTable how to render the headers and rows through the `render` prop. This prop takes a function that will receive as arguments the processed rows/headers in addition to some helper functions for rendering our table.

One common hurdle with the DataTable is how to access data that might be not correspond with a table column but is needed to compute the value of a cell that does. The DataTable component process and controls only the row properties which corresponds to headers (columns). Because of this, the `rows` object you get access to in the render prop function is _different_ than the one you passed in to the `rows` prop.

To handle this, we just need a simple look-up function to find the data we care about. We can normalize the data or just pass it right back as we do in the `getRowDescription` function.

```javascript
const RepoTable = ({ rows, headers }) => {
  const getRowDescription = rowId => {
    const row = rows.find(({ id }) => id === rowId);
    return row ? row.description : '';
  };

  return (
    <DataTable
      rows={rows}
      headers={headers}
      render={({
        rows, // This is different than the rows you passed in
        headers,
        getHeaderProps,
        getRowProps,
        getTableProps,
      }) => (
        <TableContainer
          title="Carbon Repositories"
          description="A collection of all of the public Carbon repositories.">
          <Table {...getTableProps()}>
            <TableHead>
              <TableRow>
                <TableExpandHeader />
                {headers.map(header => (
                  <TableHeader {...getHeaderProps({ header })}>
                    {header.header}
                  </TableHeader>
                ))}
              </TableRow>
            </TableHead>
            <TableBody>
              {rows.map(row => (
                <React.Fragment key={row.id}>
                  <TableExpandRow {...getRowProps({ row })}>
                    {row.cells.map(cell => (
                      <TableCell key={cell.id}>{cell.value}</TableCell>
                    ))}
                  </TableExpandRow>
                  <TableExpandedRow colSpan={headers.length + 1}>
                    <p className="description">{getRowDescription(row.id)}</p>
                  </TableExpandedRow>
                </React.Fragment>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      )}
    />
  );
};

// Don't forget to export!
export default RepoTable;
```

### Notes

The `getTableProps`, `getHeaderProps`, and `getRowProps` functions each tell the DataTable component to process and return the necessary props that are needed by the Table, Header and Row components respectively. We take the return of that function (an object containing the props) and [spread it out](https://reactjs.org/docs/jsx-in-depth.html#spread-attributes) into the component.
